package com.oono.java3;
/*
 * super关键字的使用
 * 1. super：可以理解为“父类的”
 * 2. super：可以用来call:属性、方法、构造器
 * 
 * 3. super的使用
 * 
 * 		3.1 我们可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显式地调用父类中声明的属性或方法。
 * 		但是，通常我们可以省略super
 * 		3.2 特殊情况：当子类和父类中定义了同名的属性时，我们想在子类中调用父类中声明的属性，则必须显式地使用“super.属性”
 * 		的方式，表明调用是父类中声明的属性
 * 		(实际开发中，我们通常都不会在子父类中定义这种重名的属性)
 * 		3.3 方法：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，
 * 		则必须显示地使用"super.方法"的方式，表明调用的是父类中被重写的方法
 * 	
 * 4. super来调用构造器
 * 		
 * 		4.1 我们可以在子类的构造器中显式地使用“super(形参列表)”的方式，调用父类中的构造器
 * 		4.2 “super(形参列表)”的使用，也必须声明在子类构造器的首行
 * 		4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
 * 		(因为之前讲过，构造器中调用别的构造器只能调用一个）
 * 		4.4 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，
 * 		则默认调用的是父类中空参的构造器！（这点需要注意）
 * 		相当于每次用Eclipse去快速创建构造器，都会有一行super(),就是这个意思
 * 		e.g public Student(){
 * 				super();
 * 			}
 *		表示默认会去继承其父类的空参构造器
 *		e.g public Student(String major){ 
 * 				super();
 * 				this.major = major;
 * 			}
 * 		和上面一样。
 * 		所以：我们在写构造器的时候，如果不去call其他的构造器，则by default系统会调父类的空参构造器
 * 		super()可有可无。不写，系统也会去调。写了，系统去执行它本身，也是一样（只是不给你添加这行代码了）。
 * 		4.5 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器
 * 
 * 
 */
public class SuperTest {
	
	public static void main(String[] args) {
		
		Student s = new Student();
		s.show();
		
		System.out.println();
		
		s.study();
		
		Student s1 = new Student("Tom", 21, "IT");
		s1.show();
		
	}
	
	
}
